---
title: "verify_estimators"
author: "Haotian Zheng"
date: "2024-08-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(SimEngine)
```



This file try to verify the bias of Survival estimators, and the variance of it using a Bootstrap method.
It can be ran both locally and in a cluster.
```{r}
create_data = function(n, surv_type, surv_params) {
  # id
  id = seq(1, n)
  
  # treatment
  treat = sample(0:1, n, replace = TRUE, prob = c(0.3, 0.7))
  
  # X1
  X1 = rnorm(n = n, mean = 24.3, sd = 8.38)
  
  # X2
  X2 = rnorm(n = n, mean = 266.84, sd = 507.82)
  
  # biomarker
  S = rtruncnorm(n = n, a = 0, b = 1, mean = 0.5, sd = 0.2) # truncated normal in (0, 1)
  prob_tmp = 1 / (1 + exp(- 0.05*X1 + 0.005*X2 + treat)) # to make edge_prob distributed not too extremely
  val_tmp = rbinom(n, prob = prob_tmp, size = 1)
  S = (1 - val_tmp) * S
  
  # survival time
  U = runif(n = n)
  if (surv_type == "Exponential") {
    lambda = surv_params
    t = -log(U) / (lambda * exp(0.15*X1 + 0.001*X2 - 5*S + treat))
  } else if (surv_type == "Gompertz") {
    alpha = surv_params[1]
    lambda = surv_params[2]
    t = 1/alpha * log(1 - (alpha * log(U)) / (lambda * exp(0.15*X1 + 0.001*X2 - 5*S + treat)))
  }
  
  # censore time
  U = runif(n = n)
  if (surv_type == "Exponential") {
    lambda = surv_params
    C = - log(U) / (lambda * exp(0.15*X1 + 0.001*X2))
  } else if (surv_type == "Gompertz") {
    alpha = surv_params[1]
    lambda = surv_params[2]
    C = (- 1/lambda * log(U) * exp(0.15*X1 + 0.001*X2)) ^ (alpha)
  }
  
  # delta
  delta = ifelse(t <= C, 1, 0)
  
  # observed time
  Y = pmin(t, C)
  
  # two-phase indicator
  t0 = 200 # set the time of interest
  prob_tmp = 1 / (1 + exp(0.15*X1 + 0.001*X2 - 1))
  Z = delta*I(Y <= t0) + (1 - delta*I(Y <= t0)) * rbinom(n = n, size = 1, prob = prob_tmp)
  
  # temporary dataframe
  data = data.frame("id" = id, "treat" = treat, "Y" = Y, "delta" = delta, "S" = S, "X1" = X1, "X2" = X2, "Z" = Z)
  
  # using ipwpoint function to generate inverse probability weights
  ip_weights = ipwpoint(
    exposure = Z,
    family = "binomial",  # The treatment is binary
    link = "logit",
    denominator = ~ treat + delta + S + X1 + X2,
    data = data
  )$ipw.weights
  #ip_weights = 1 / prob_tmp # we can also use this directly as the ip_weights
  
  # final data
  data = data %>% 
    dplyr::mutate(ipw = ip_weights)
  
  return(data)
}
```



functions of true survival, Coxph estimated and Two-phase sampling estimated
```{r}
# true survival function
surv_true = function(surv_type, surv_params, model, t, data) {
  if (surv_type == "Exponential") {
    lambda = surv_params
    Q_0 = exp(- lambda * t)
  } else if ( surv_type == "Gompertz") {
    alpha = surv_params[1]
    lambda = surv_params[2]
    Q_0 = exp(lambda/alpha * (1 - exp(alpha*t)))
  }
  beta = model$coefficients
  X_S = data[, c(names(model$coefficients))]
  result = mean(Q_0 ^ (exp(beta %*% t(X_S))))
  return((result))
}

# Coxph estimated survival function
surv_cox = function(model, t) {
  Q_fit = survfit(model)
  index = which.min(abs(Q_fit$time - t))
  result = Q_fit$surv[index]
  return(result)
}

# Two Phase Sampling estimated survival function
surv_two = function(model, t, wt, data) {
  bh_1 = basehaz(model, centered = F)
  index = which.min(abs(bh_1$time - t))
  
  Q_0 = bh_1$hazard[index]
  
  beta = model$coefficients
  X_S = data[, c(names(model$coefficients))]
  proportional = exp(beta %*% t(X_S))
  
  result = exp(- Q_0 * wt * proportional)
  return(mean(result))
}
```



```{r}
# start time
start_time = Sys.time()

# set up multi-cores
run_on_cluster(
  # use SimEngine
  first = {
    sim = new_sim()
    
    sim %<>% set_levels(
      n = c(500, 1000, 5000),
      surv_time = list(
        "Exp" = list(surv_type = "Exponential", surv_params = 1.5e-2), # may be some problems
        "Gom" = list(surv_type = "Gompertz", surv_params = c(0.2138, 7e-8))
      )
    )
    
    create_data = function(n, surv_type, surv_params) {
      # id
      id = seq(1, n)
      
      # treatment
      treat = sample(0:1, n, replace = TRUE, prob = c(0.3, 0.7))
      
      # X1
      X1 = rnorm(n = n, mean = 24.3, sd = 8.38)
      
      # X2
      X2 = rnorm(n = n, mean = 266.84, sd = 507.82)
      
      # biomarker
      S = rtruncnorm(n = n, a = 0, b = 1, mean = 0.5, sd = 0.2) # truncated normal in (0, 1)
      prob_tmp = 1 / (1 + exp(- 0.05*X1 + 0.005*X2 + treat)) # to make edge_prob distributed not too extremely
      val_tmp = rbinom(n, prob = prob_tmp, size = 1)
      S = (1 - val_tmp) * S
      
      # survival time
      U = runif(n = n)
      if (surv_type == "Exponential") {
        lambda = surv_params
        t = -log(U) / (lambda * exp(0.15*X1 + 0.001*X2 - 5*S + treat))
      } else if (surv_type == "Gompertz") {
        alpha = surv_params[1]
        lambda = surv_params[2]
        t = 1/alpha * log(1 - (alpha * log(U)) / (lambda * exp(0.15*X1 + 0.001*X2 - 5*S + treat)))
      }
      
      # censore time
      U = runif(n = n)
      if (surv_type == "Exponential") {
        lambda = surv_params
        C = - log(U) / (lambda * exp(0.15*X1 + 0.001*X2))
      } else if (surv_type == "Gompertz") {
        alpha = surv_params[1]
        lambda = surv_params[2]
        C = (- 1/lambda * log(U) * exp(0.15*X1 + 0.001*X2)) ^ (alpha)
      }
      
      # delta
      delta = ifelse(t <= C, 1, 0)
      
      # observed time
      Y = pmin(t, C)
      
      # two-phase indicator
      t0 = 200 # set the time of interest
      prob_tmp = 1 / (1 + exp(0.15*X1 + 0.001*X2 - 1))
      Z = delta*I(Y <= t0) + (1 - delta*I(Y <= t0)) * rbinom(n = n, size = 1, prob = prob_tmp)
      
      # temporary dataframe
      data = data.frame("id" = id, "treat" = treat, "Y" = Y, "delta" = delta, "S" = S, "X1" = X1, "X2" = X2, "Z" = Z)
      
      # using ipwpoint function to generate inverse probability weights
      ip_weights = ipwpoint(
        exposure = Z,
        family = "binomial",  # The treatment is binary
        link = "logit",
        denominator = ~ treat + delta + S + X1 + X2,
        data = data
      )$ipw.weights
      #ip_weights = 1 / prob_tmp # we can also use this directly as the ip_weights
      
      # final data
      data = data %>% 
        dplyr::mutate(ipw = ip_weights)
      
      return(data)
    }
    
    sim %<>% set_config(num_sim = 1000, n_cores = 4, seed = 1018,
                        packages = c("survival", "parallel", "truncnorm", "devtools", "ipw")
                        )
    
    sim %<>% set_script(function() {
      dat_phaseOne = create_data(L$n, L$surv_time$surv_type, L$surv_time$surv_params)
      model_one = coxph(Surv(Y, delta) ~ X1 + X2 + S, data = dat_phaseOne, weights = ipw)
      dat_phaseTwo = dat_phaseOne %>%
        dplyr::filter(Z == 1 & treat == 1) # use phase two data
      model_two = coxph(Surv(Y, delta) ~ X1 + X2 + S, data = dat_phaseTwo, weights = ipw)
      wt_phase = nrow(dat_phaseTwo) / nrow(dat_phaseOne)
      
      # choose a specific time
      t = quantile(dat_phaseTwo$Y, probs = 0.5)
      
      Q_true = surv_true(L$surv_time$surv_type, L$surv_time$surv_params, model_one, t, dat_phaseOne)
      Q_est_cox = surv_cox(model_one, t)
      Q_est_two = surv_two(model_two, t, wt_phase, dat_phaseTwo)
      
      return(list(
        "Q_true" = Q_true,
        "Q_est_cox" = Q_est_cox,
        "Q_est_two" = Q_est_two,
        "cox_pctg" = (Q_est_cox - Q_true) / Q_true * 100,
        "two_pctg" = (Q_est_two - Q_true) / Q_true *100,
        ".complex" = list(
          "model" = model_two,
          "data" = dat_phaseTwo
        )
      ))
    })
  },
  
  main = {
    sim %<>% run()
    print(sim$errors)
  },
  
  last = {
    # mean
    Q_true = sim %>% SimEngine::summarize(list(stat = "mean", x = "Q_true"))
    Q_est_cox = sim %>% SimEngine::summarize(list(stat = "mean", x = "Q_est_cox"))
    Q_est_two = sim %>% SimEngine::summarize(list(stat = "mean", x = "Q_est_two"))
    # bias
    bias_Q = sim %>% SimEngine::summarize(
      list(stat = "bias", estimate = "Q_est_cox", truth = "Q_true", name = "bias_cox"),
      list(stat = "bias", estimate = "Q_est_two", truth = "Q_true", name = "bias_twophase")
      # list(stat = "coverage", estimate = "beta_X1_hat", se = "beta_X1_se", truth = 0.15, name = "cov_beta_X1"),
    )
    # bias percentage
    bias_Q_pct = sim %>% SimEngine::summarize(
      list(stat = "mean", x = "cox_pctg", name = "bias_cox_pct"),
      list(stat = "mean", x = "two_pctg", name = "bias_twophase_pct")
    )
  },
  
  cluster_config = list(js = "slurm")
)



# end time
end_time = Sys.time()
execution_time = end_time - start_time
print(execution_time)
```



